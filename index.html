<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Posture Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <style>
        body { text-align: center; font-family: Arial, sans-serif; }
        canvas { border: 2px solid black; margin-top: 10px; }
        #status { font-size: 20px; margin-top: 10px; }
    </style>
</head>
<body>

    <h1>Real-Time Posture Analysis</h1>
    <video id="video" autoplay playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>
    <div id="status">Waiting for pose data...</div>

    <script>
        let video = document.getElementById("video");
        let canvas = document.getElementById("canvas");
        let ctx = canvas.getContext("2d");
        let repCount = 0;
        let elbowDown = false;
        let audioPlaying = false;  // To prevent multiple audio triggers

        // Function to play feedback audio
        function playAudio(audioFile) {
            if (!audioPlaying) {
                audioPlaying = true;
                let audio = new Audio(audioFile);
                audio.play();
                audio.onended = () => { audioPlaying = false; }; // Reset flag after playing
            }
        }

        // Function to calculate the angle between three points
        function calculateAngle(a, b, c) {
            let ab = [a.x - b.x, a.y - b.y];
            let bc = [c.x - b.x, c.y - b.y];
            let dotProduct = ab[0] * bc[0] + ab[1] * bc[1];
            let magnitudeAB = Math.sqrt(ab[0] ** 2 + ab[1] ** 2);
            let magnitudeBC = Math.sqrt(bc[0] ** 2 + bc[1] ** 2);
            let angle = Math.acos(dotProduct / (magnitudeAB * magnitudeBC)) * (180 / Math.PI);
            return angle;
        }

        async function setupCamera() {
            video.width = 640;
            video.height = 480;
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => { resolve(video); };
            });
        }

        async function detectPose() {
            const net = await posenet.load();
            await setupCamera();

            canvas.width = video.width;
            canvas.height = video.height;

            async function poseDetectionFrame() {
                const pose = await net.estimateSinglePose(video, { flipHorizontal: false });
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                let keypoints = pose.keypoints;
                let rightShoulder = keypoints[6].position;
                let rightElbow = keypoints[8].position;
                let rightHip = keypoints[12].position;
                let rightAnkle = keypoints[16].position;

                // Calculate angles
                let backAngle = calculateAngle(rightShoulder, rightHip, rightAnkle);
                let elbowAngle = calculateAngle(rightElbow, rightShoulder, rightHip);

                // Check form mistakes
                let backMistake = backAngle < 168 || backAngle > 180;
                let elbowMistake = elbowAngle > 70;

                // Rep counting based on shoulder-ankle vertical distance
                if (Math.abs(rightShoulder.y - rightAnkle.y) < 240) {
                    elbowDown = true;
                }
                if (Math.abs(rightShoulder.y - rightAnkle.y) >= 240 && elbowDown) {
                    repCount++;
                    elbowDown = false;

                    // Play audio feedback when a rep is completed
                    if (elbowMistake) {
                        playAudio("elbows.mp3");
                    } else if (backMistake) {
                        playAudio("back.mp3");
                    }
                }

                // Draw keypoints
                ctx.fillStyle = "red";
                [rightShoulder, rightElbow, rightHip, rightAnkle].forEach(pt => {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });

                // Draw lines
                ctx.strokeStyle = backMistake ? "red" : "green";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(rightShoulder.x, rightShoulder.y);
                ctx.lineTo(rightHip.x, rightHip.y);
                ctx.lineTo(rightAnkle.x, rightAnkle.y);
                ctx.stroke();

                ctx.strokeStyle = elbowMistake ? "red" : "green";
                ctx.beginPath();
                ctx.moveTo(rightElbow.x, rightElbow.y);
                ctx.lineTo(rightShoulder.x, rightShoulder.y);
                ctx.lineTo(rightHip.x, rightHip.y);
                ctx.stroke();

                // Display status
                let statusText = `Reps: ${repCount} | Back: ${backMistake ? "Bent ❌" : "Straight ✅"} | Elbow: ${elbowMistake ? "Too Wide ❌" : "Good ✅"}`;
                document.getElementById("status").innerText = statusText;

                requestAnimationFrame(poseDetectionFrame);
            }

            poseDetectionFrame();
        }

        detectPose();
    </script>
</body>
</html>
